/**
 * Step B.2 - Skill Coverage Mapping
 * Determines which requested skills are covered by existing topics
 * and which ones must be generated by AI.
 * Priority: Trainer Topic > Course Topic > Standalone Topic > AI
 * 
 * @param {Array<string>} requestedSkills - Array of skill names
 * @param {Array<Object>} courseTopics - Array of full topic objects from archived course
 * @param {Array<Object>} trainerTopics - Array of full topic objects from trainer (optional)
 * @param {Array<Object>} standaloneTopics - Array of full topic objects from standalone lookup (optional)
 * @returns {Array<Object>} Array of skill coverage objects
 */
export function mapSkillCoverage(requestedSkills, courseTopics, trainerTopics = [], standaloneTopics = []) {
  // Normalize inputs
  const skills = Array.isArray(requestedSkills) ? requestedSkills : [];
  const courseTopicsList = Array.isArray(courseTopics) ? courseTopics : [];
  const trainerTopicsList = Array.isArray(trainerTopics) ? trainerTopics : [];
  const standaloneTopicsList = Array.isArray(standaloneTopics) ? standaloneTopics : [];

  // Filter only active/archived topics (not deleted)
  const validCourseTopics = courseTopicsList.filter(topic => topic.status !== 'deleted');
  const validTrainerTopics = trainerTopicsList.filter(topic => topic.status !== 'deleted');
  const validStandaloneTopics = standaloneTopicsList.filter(topic => topic.status !== 'deleted');

  // Build skill-to-topic maps for quick lookup
  // Priority: trainer > course > standalone
  const trainerSkillMap = new Map();
  const courseSkillMap = new Map();
  const standaloneSkillMap = new Map();

  // Map trainer topics to their skills (highest priority)
  for (const topic of validTrainerTopics) {
    if (topic.skills && Array.isArray(topic.skills)) {
      for (const skill of topic.skills) {
        if (skill && typeof skill === 'string') {
          const normalizedSkill = skill.toLowerCase().trim();
          // Trainer topics have highest priority, only set if not already mapped
          if (!trainerSkillMap.has(normalizedSkill)) {
            trainerSkillMap.set(normalizedSkill, topic);
          }
        }
      }
    }
  }

  // Map course topics to their skills
  for (const topic of validCourseTopics) {
    if (topic.skills && Array.isArray(topic.skills)) {
      for (const skill of topic.skills) {
        if (skill && typeof skill === 'string') {
          const normalizedSkill = skill.toLowerCase().trim();
          // Course topics have second priority, only set if not already mapped by trainer
          if (!trainerSkillMap.has(normalizedSkill) && !courseSkillMap.has(normalizedSkill)) {
            courseSkillMap.set(normalizedSkill, topic);
          }
        }
      }
    }
  }

  // Map standalone topics to their skills
  for (const topic of validStandaloneTopics) {
    if (topic.skills && Array.isArray(topic.skills)) {
      for (const skill of topic.skills) {
        if (skill && typeof skill === 'string') {
          const normalizedSkill = skill.toLowerCase().trim();
          // Only set if not already mapped (trainer and course have priority)
          if (!trainerSkillMap.has(normalizedSkill) && !courseSkillMap.has(normalizedSkill) && !standaloneSkillMap.has(normalizedSkill)) {
            standaloneSkillMap.set(normalizedSkill, topic);
          }
        }
      }
    }
  }

  // Map each requested skill to its coverage status
  const result = [];

  for (const skill of skills) {
    if (!skill || typeof skill !== 'string') {
      continue;
    }

    const normalizedSkill = skill.toLowerCase().trim();

    // Check trainer topics first (highest priority)
    if (trainerSkillMap.has(normalizedSkill)) {
      result.push({
        skill: skill,
        status: 'found',
        source: 'trainer',
        topic: trainerSkillMap.get(normalizedSkill),
      });
    }
    // Check course topics second
    else if (courseSkillMap.has(normalizedSkill)) {
      result.push({
        skill: skill,
        status: 'found',
        source: 'course',
        topic: courseSkillMap.get(normalizedSkill),
      });
    }
    // Check standalone topics third
    else if (standaloneSkillMap.has(normalizedSkill)) {
      result.push({
        skill: skill,
        status: 'found',
        source: 'standalone',
        topic: standaloneSkillMap.get(normalizedSkill),
      });
    }
    // Not found - must be generated by AI
    else {
      result.push({
        skill: skill,
        status: 'missing',
        source: 'ai',
      });
    }
  }

  return result;
}

