/**
 * Step B.2 - Skill Coverage Mapping
 * Determines which requested skills are covered by existing topics
 * and which ones must be generated by AI.
 * Priority: Course Topic > Standalone Topic > AI
 * 
 * @param {Array<string>} requestedSkills - Array of skill names
 * @param {Array<Object>} courseTopics - Array of full topic objects from archived course
 * @param {Array<Object>} standaloneTopics - Array of full topic objects from standalone lookup
 * @returns {Array<Object>} Array of skill coverage objects
 */
export function mapSkillCoverage(requestedSkills, courseTopics, standaloneTopics) {
  // Normalize inputs
  const skills = Array.isArray(requestedSkills) ? requestedSkills : [];
  const courseTopicsList = Array.isArray(courseTopics) ? courseTopics : [];
  const standaloneTopicsList = Array.isArray(standaloneTopics) ? standaloneTopics : [];

  // Filter only archived topics
  const validCourseTopics = courseTopicsList.filter(topic => topic.status === 'archived');
  const validStandaloneTopics = standaloneTopicsList.filter(topic => topic.status === 'archived');

  // Build skill-to-topic maps for quick lookup
  const courseSkillMap = new Map();
  const standaloneSkillMap = new Map();

  // Map course topics to their skills
  for (const topic of validCourseTopics) {
    if (topic.skills && Array.isArray(topic.skills)) {
      for (const skill of topic.skills) {
        if (skill && typeof skill === 'string') {
          const normalizedSkill = skill.toLowerCase().trim();
          // Course topics have priority, only set if not already mapped
          if (!courseSkillMap.has(normalizedSkill)) {
            courseSkillMap.set(normalizedSkill, topic);
          }
        }
      }
    }
  }

  // Map standalone topics to their skills
  for (const topic of validStandaloneTopics) {
    if (topic.skills && Array.isArray(topic.skills)) {
      for (const skill of topic.skills) {
        if (skill && typeof skill === 'string') {
          const normalizedSkill = skill.toLowerCase().trim();
          // Only set if not already mapped (course has priority)
          if (!courseSkillMap.has(normalizedSkill) && !standaloneSkillMap.has(normalizedSkill)) {
            standaloneSkillMap.set(normalizedSkill, topic);
          }
        }
      }
    }
  }

  // Map each requested skill to its coverage status
  const result = [];

  for (const skill of skills) {
    if (!skill || typeof skill !== 'string') {
      continue;
    }

    const normalizedSkill = skill.toLowerCase().trim();

    // Check course topics first (priority)
    if (courseSkillMap.has(normalizedSkill)) {
      result.push({
        skill: skill,
        status: 'found',
        source: 'course',
        topic: courseSkillMap.get(normalizedSkill),
      });
    }
    // Check standalone topics second
    else if (standaloneSkillMap.has(normalizedSkill)) {
      result.push({
        skill: skill,
        status: 'found',
        source: 'standalone',
        topic: standaloneSkillMap.get(normalizedSkill),
      });
    }
    // Not found - must be generated by AI
    else {
      result.push({
        skill: skill,
        status: 'missing',
        source: 'ai',
      });
    }
  }

  return result;
}

