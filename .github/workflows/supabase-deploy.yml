name: Supabase Database Migration

on:
  push:
    branches: [ main ]
    paths:
      - 'database/**'
      - 'backend/database/**'
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy Database Migrations
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      # ‚úÖ Use the official Supabase CLI installer
      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Verify Supabase CLI installed
        run: |
          supabase --version
          which supabase

      - name: Verify Supabase Secrets
        run: |
          if [ -z "${{ secrets.SUPABASE_PROJECT_REF }}" ]; then
            echo "‚ùå ERROR: SUPABASE_PROJECT_REF is not set in GitHub secrets"
            echo "Please add it in: Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "To find it: Go to Supabase Dashboard ‚Üí Project Settings ‚Üí General ‚Üí Reference ID"
            exit 1
          fi
          if [ -z "${{ secrets.SUPABASE_ACCESS_TOKEN }}" ]; then
            echo "‚ùå ERROR: SUPABASE_ACCESS_TOKEN is not set in GitHub secrets"
            echo "Please add it in: Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "To get it: Go to https://supabase.com/dashboard/account/tokens"
            exit 1
          fi
          echo "‚úÖ Supabase secrets are configured"

      - name: Link to Supabase Project
        run: |
          supabase link --project-ref "${{ secrets.SUPABASE_PROJECT_REF }}"
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      - name: Verify Supabase Connection
        run: supabase db list
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Parse database connection info
        id: parse-db
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          python <<'PY'
          import os, urllib.parse
          url = os.environ['DATABASE_URL']
          parsed = urllib.parse.urlparse(url)
          password = urllib.parse.unquote(parsed.password or '')
          print(f"::add-mask::{password}")
          outputs = {
              'host': parsed.hostname or '',
              'port': parsed.port or 5432,
              'user': parsed.username or '',
              'dbname': (parsed.path or '').lstrip('/') or 'postgres',
              'password': password,
          }
          with open(os.environ['GITHUB_OUTPUT'], 'w') as f:
              for key, value in outputs.items():
                  f.write(f"{key}={value}\n")
          PY

      - name: Resolve Supabase IPv4 Address
        id: resolve-ipv4
        run: |
          set -e
          echo "Resolving IPv4 for ${{ steps.parse-db.outputs.host }}..."
          ipv4=$(dig +short A "${{ steps.parse-db.outputs.host }}" | head -n 1)
          if [ -z "$ipv4" ]; then
            echo "‚ùå ERROR: Unable to resolve IPv4 address for ${{ steps.parse-db.outputs.host }}"
            exit 1
          fi
          echo "IPv4 address: $ipv4"
          echo "ipv4=$ipv4" >> $GITHUB_OUTPUT

      - name: Diagnose Supabase DNS resolution
        run: |
          set -e
          echo "Resolving ${{ steps.parse-db.outputs.host }}..."
          host "${{ steps.parse-db.outputs.host }}" || true
          dig +short "${{ steps.parse-db.outputs.host }}" || true

      # ‚úÖ Run all SQL files under database/migrations/ and backend/database/migrations/
      - name: Run Custom Migrations
        run: |
          set -euo pipefail
          export PGSSLMODE=require
          echo "üöÄ Running custom migrations from database/migrations and backend/database/migrations..."
          echo "Testing IPv4 connectivity to $PGHOST:$PGPORT..."
          if ! PGPASSWORD="$PGPASSWORD" psql -4 -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -c '\conninfo' >/dev/null 2>&1; then
            echo "‚ùå ERROR: Cannot reach $PGHOST via IPv4. Exiting."
            exit 1
          fi

          # Function to check if migration was already executed successfully
          check_migration_executed() {
            local file=$1
            local filename=$(basename "$file")
            # Check if migration_log table exists and if this file was executed successfully
            local result=$(PGPASSWORD="$PGPASSWORD" psql -4 -t -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -c "SELECT COUNT(*) FROM migration_log WHERE file_name = '$filename' AND success = true;" 2>/dev/null || echo "0")
            if [ "$result" -gt 0 ] 2>/dev/null; then
              echo "‚è≠Ô∏è Migration $filename already executed successfully, skipping..."
              return 0
            fi
            return 1
          }

          # Function to run migration file with retry logic
          run_migration() {
            local file=$1
            local filename=$(basename "$file")
            
            # Check if migration was already executed successfully
            if check_migration_executed "$file"; then
              return 0
            fi
            
            echo "Executing $file..."
            attempts=0
            until [ "$attempts" -ge 3 ]; do
              # Wrap migration in a transaction to ensure atomicity
              # Use -f to execute file and then log the result
              if PGPASSWORD="$PGPASSWORD" psql -4 -v ON_ERROR_STOP=1 -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -f "$file" && \
                 PGPASSWORD="$PGPASSWORD" psql -4 -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -c "INSERT INTO migration_log (file_name, success, execution_duration_ms) VALUES ('$filename', true, 0) ON CONFLICT (file_name) DO UPDATE SET success = true, executed_at = CURRENT_TIMESTAMP, error_message = NULL;"
              then
                echo "‚úÖ Executed $file"
                return 0
              fi
              attempts=$((attempts+1))
              echo "Attempt $attempts failed, retrying in $((attempts*5)) seconds..."
              sleep $((attempts*5))
            done
            echo "‚ùå ERROR: Failed to execute $file after $attempts attempts."
            # Log failed migration
            PGPASSWORD="$PGPASSWORD" psql -4 -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -d "$PGDATABASE" -c "INSERT INTO migration_log (file_name, success, error_message) VALUES ('$filename', false, 'Failed after 3 attempts') ON CONFLICT (file_name) DO UPDATE SET success = false, error_message = 'Failed after 3 attempts';" 2>/dev/null || true
            return 1
          }

          # Run migrations from database/migrations/ if it exists
          if [ -d "database/migrations" ]; then
            for file in database/migrations/*.sql; do
              if [ -f "$file" ]; then
                run_migration "$file" || exit 2
              fi
            done
          fi

          # Run migrations from backend/database/migrations/ if it exists
          if [ -d "backend/database/migrations" ]; then
            for file in backend/database/migrations/*.sql; do
              if [ -f "$file" ]; then
                run_migration "$file" || exit 2
              fi
            done
          fi

          echo "‚úÖ All migrations executed successfully."
        env:
          PGHOST: ${{ steps.resolve-ipv4.outputs.ipv4 }}
          PGPORT: ${{ steps.parse-db.outputs.port }}
          PGUSER: ${{ steps.parse-db.outputs.user }}
          PGDATABASE: ${{ steps.parse-db.outputs.dbname }}
          PGPASSWORD: ${{ steps.parse-db.outputs.password }}

      - name: Migration Summary
        run: echo "‚úÖ Supabase custom migrations completed successfully!"

      - name: Notify on failure
        if: failure()
        run: echo "‚ùå Database migration failed! Please check the logs."
